#!/bin/bash

#
# Each phoronix test will produce a different results file.  Some of those
# results files follow a given pattern, others do not.  For those that follow
# a given pattern there may exist an existing function to reduce it.  Others
# are unique enough that they will require their own function.
#
out_file=""
sub_test=""
in_file=""

error_out()
{
	echo $1
	exit $2
}


#
# reduce_line1_same_3_lines()
#
# In the line that matches Field 1 we want the entries for field 2 and 3 (fields as
# defined by awk)
# After that we will locate the line that matches $3, and pull the value
# Match on $4 and pull the value.
#
# call for cockroach
#  reduce_line1_same_3_lines "Workload:Concurrency:Average:Deviation" "Workload" "Average" "Deviation"
# 
# Sample output, cockroach
#    Workload: KV, 95% Reads - Concurrency: 1024:
#        8302.9
#        8277.6
#        8339.5
#
#    Average: 8306.7 ops/s
#    Deviation: 0.37%
#
# So we will pull 95% and 1024  from Workload level.
# For average we will pull 8306.7
# For deviation we will pull 0.37%
#

reduce_line1_same_3_lines()
{
	header="$1"
	field1="$2"
	field2="$3"
	field3="$4"

	#
	# Out file is expected to contain the meta_data already, done in
	# run_phoronix.sh.
	#
	echo $header >> "$out_file"
	while IFS= read -r line; do
	        # Check for lines containing workload and concurrency
        	if [[ $line == *"${field1}"* ]]; then
            		# Extract First 2 fields
            		val1=$(echo "$line" | awk -F ': ' '{print $2}' | awk -F ' - ' '{print $1}')
			echo $line
			echo $val1
            		val2=$(echo "$line" | awk -F ': ' '{print $3}' | tr -d ':')
        	fi
        	if [[ $line == *"${field2}"* ]]; then
            		val3=$(echo "$line" | awk -F ': ' '{print $2}' | awk '{print $1}')
        	fi
        	if [[ $line == *"${field3}"* ]]; then
            		val4=$(echo "$line" | awk -F ': ' '{print $2}' | tr -d '%')
	    		echo  "$val1:$val2:$val3:$val4" | sed "s/\[1\;34m//g" >> $out_file
        	fi
	done < "${in_file}"
	exit 0
}

#
# reduce_2_fields
#
# For results that have two lines of information interested in.
#
# Field 1: Is the csv header to provide
# Field 2: String of field looking for.
# Field 3: String of field looking for.
#
# Example php benchmark results
#
#    PHP Benchmark Suite:
#        523106
#        522353
#        522709
#  
#    Average: ^[[1;34m522723 Score^[[0m
#    Deviation: 0.07%
#
# We are intersted in Average and deviation
# The call would be
#   reduce_2_fields "Average:Deviation" "Average:" "Deviation:"
#

reduce_2_fields()
{
	header="$1"
	field1="$2"
	field2="$3"

	echo "$header" >> $out_file
	while IFS= read -r line; do
		if [[ $line == *"${field1}"* ]]; then
			# Extract Test name (after field1 and before the colon)
			f1=$(echo "$line" | awk -F "${field1} " '{print $2}' | awk -F ':' '{print $1}')
		fi
		if [[ $line == *"${field2}"* ]]; then
			# Extract field3 value
			f2=$(echo "$line" | awk -F "${field3} " '{print $2}' | tr -d '%')
			# Append the extracted information to the output file
	    		echo  "$f1:$f2" | sed "s/\[1\;34m//g" >> $out_file
		fi
	done < "$in_file"
	exit 0
}

#
# reduce_3_fields(
#  This function is used to reduce results from test that generates 3 fields to each line.
#
#  $1: Is the header of the csv file
#
#  $2 through $4 are names of the fields looking for.
#  For example, output of a test from stress-ng
#  
#    Test: Memory Copying:
#        459.34
#        457.84
#        460.67
#
#    Average: 459.28 Bogo Ops/s
#    Deviation: 0.31%
#
#    field2 would be Test:
#    field3 would be Average:
#    field4 would be Deviation.
#
reduce_3_fields()
{
	header="$1"
	field1="$2"
	field2="$3"
	field3="$4"

	echo "$header" >> $out_file
	while IFS= read -r line; do
		if [[ $line == *"${field1}"* ]]; then
			# Extract Test name (after field1 and before the colon)
			f1=$(echo "$line" | awk -F "${field1} " '{print $2}' | awk -F ':' '{print $1}')
		fi
		if [[ $line == *"${field2}"* ]]; then
			# Extract field2 value
			f2=$(echo "$line" | awk -F "${field2} " '{print $2}' | awk '{print $1}')
		fi
		if [[ $line == *"${field3}"* ]]; then
			# Extract field3 value
			f3=$(echo "$line" | awk -F "${field3} " '{print $2}' | tr -d '%')
			# Append the extracted information to the output file
	    		echo  "$f1:$f2:$f3" | sed "s/\[1\;34m//g" >> $out_file
		fi
	done < "$in_file"
	exit 0
}

#
# Results are unique enough for apache-iotb to require its own reduce function.
#
reduce_apache-iotdb()
{
	# Header for CSV file
	echo "device_count:batch_size:sensor_count:client_number:point_sec:latency" >> "$out_file"

	# Initialize variables to store values for each test configuration
	device_count=""
	batch_size=""
	sensor_count=""
	client_number=""
	point_sec=""
	latency=""
	# Iterate through the test output file (replace this with the actual test output file)
	while IFS= read -r line; do
		# Extract the configuration line (e.g., Device Count: 100 - Batch Size Per Write: 1 - Sensor Count: 200 - Client Number: 100)
		if [[ "$line" =~ \[\Device\ Count:\ ([0-9]+).*Batch\ Size\ Per\ Write:\ ([0-9]+).*Sensor\ Count:\ ([0-9]+).*Client\ Number:\ ([0-9]+)] ]]; then
			# Save the configuration
			device_count="${BASH_REMATCH[1]}"
			batch_size="${BASH_REMATCH[2]}"
			sensor_count="${BASH_REMATCH[3]}"
			client_number="${BASH_REMATCH[4]}"
		fi
		# Extract points/sec (e.g., Average: 139645 point/sec)
		if [[ "$line" =~ Average:\ ([0-9]+)\ point/sec ]]; then
			point_sec="${BASH_REMATCH[1]}"
		fi
		# Extract latency (e.g., Average Latency: 117.59)
		if [[ "$line" =~ Average\ Latency:\ ([0-9]+\.[0-9]+) ]]; then
			latency="${BASH_REMATCH[1]}"
		fi
		# After reading the point_sec and latency for a test configuration, append it to the output CSV
		if [[ -n "$device_count" && -n "$batch_size" && -n "$sensor_count" && -n "$client_number" ]]; then
			echo "$device_count:$batch_size:$sensor_count:$client_number:${point_sec:-}:$latency" >> "$out_file"
			device_count=""
			batch_size=""
			sensor_count=""
			client_number=""
			point_sec=""
		latency=""
		fi
	done < "$in_file"
	exit 0
}

reduce_phpbench()
{
	reduce_2_fields "Average:Deviation" "Average:" "Deviation:"
}

reduce_cassandra()
{
	reduce_3_fields "Test:Average:Deviation" "Test:" "Average:" "Deviation:"
}

reduce_openssl()
{
	reduce_3_fields "Algorithm:BPS:Deviation" "Algorithm:" "Average:" "Deviation"
}

reduce_sqlite()
{
	reduce_3_fields "Threads:Average:Deviation" "Threads / Copies:" "Average:" "Deviation:"
}

reduce_nginx()
{
	reduce_3_fields "Connections:RPS:Deviation" "Connections:" "Average:" "Deviation:"
}

reduce_stress-ng()
{
	reduce_3_fields "Test:Average:Deviation" "Test:" "Average:" "Deviation:"
}

reduce_cockroach()
{
	reduce_line1_same_3_lines "Workload:Concurrency:Average:Deviation" "Workload" "Average" "Deviation"
}

# 
# Special case test/parallel conections are on the same line
#
reduce_redis()
{
	reduce_line1_same_3_lines "Test:ParallelConnections:Average:Deviation" "Test:" "Average:" "Deviation:"
}

usage()
{
    echo "Usage:"
    echo "  ./reduce_phoronix --sub_test <test_ran> --out_file <output_file> --in_file <input file>"
    echo "Options:"
    echo "  --in_file  Specify inp file"
    echo "  --out_file  Specify output file"
    echo "  --sub_test  Specify the test data to reduce"
    echo "  -h, --usage          Show help"
    exit 1
}

ARGUMENT_LIST=(
	"in_file"
	"out_file"
	"sub_test"
)

NO_ARGUMENTS=(
        "usage"
)


# read arguments
opts=$(getopt \
    --longoptions "$(printf "%s:," "${ARGUMENT_LIST[@]}")" \
    --longoptions "$(printf "%s," "${NO_ARGUMENTS[@]}")" \
    --name "$(basename "$0")" \
    --options "h" \
    -- "$@"
)

# Report any errors
#
if [ $? -ne 0 ]; then
	error_out "Error with option parsing" 1
        exit
fi

eval set --$opts

while [[ $# -gt 0 ]]; do
        case "$1" in
		--in_file)
			in_file=$2
			shift 2
		;;
		--out_file)
			out_file=$2
			shift 2
		;;
		--sub_test)
			sub_test=$2
			shift 2
		;;
                -h)
			usage
		;;
	        --usage)
			usage
                        exit
                ;;
		--)
			break;
		;;
		*)
			echo option not found $1
			usage
			exit
		;;
        esac
done
if [[ $sub_test == "" ]]; then
	error_out "Need to designate a sub test" 1
fi
if [[ $out_file == "" ]]; then
	error_out "Need to designate an output file" 1
fi
if [[ $in_file == "" ]]; then
	error_out "Need to designate an in file." 1
fi

echo "# Subtest: $sub_test" >> $out_file
reduce="reduce_${sub_test}"
$reduce
error_out "$sub_test is not recognized for reduction" 1
